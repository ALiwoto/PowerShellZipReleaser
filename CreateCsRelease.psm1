
class CsProjectContainer {
    # The project name. Can be found in .sln file.
    [string]$ProjectName

    # The project's full file path.
    [string]$CsProjectFilePath

    # The cached value of .csproj's raw content. 
    [string]$RawContent

    # The UUID of the project.
    [string]$CsUUID

    # $true when and only when the project has been built by executing
    # dotnet build command.
    [bool]$IsBuilt = $false

    # The solution file's name that contained this cs-project originally.
    [string]$SlnName

    # Coonstructor of the CsProjectContainer class.
    CsProjectContainer(
        [string]$Path,
        [string]$TheName,
        [string]$RawContent,
        [string]$TheSlnName,
        [string]$ProjectUUID = $null
    ) {
        $this.ProjectName = $TheName
        $this.CsProjectFilePath = $Path
        $this.CsUUID = $ProjectUUID
        $this.SlnName = $TheSlnName
        if ($RawContent) {
            $this.RawContent = $RawContent
        }
        else {
            $this.RawContent = $this.GetRawContent()
        }
    }

    # Returns the raw content of the target .csproj file.
    [string]GetRawContent() {
        return Get-Content -Path $this.CsProjectFilePath -Raw
    }

    # Removes the raw content of the target .csproj file cached inside of
    # the memory.
    [void]RemoveRawContent() {
        $this.RawContent = $null;
    }

    # This method will find the <Version> </Version> XML attribute inside of
    # .csproj file content and modify it (if doesn't exist, create it).
    [void]ModifyProjectVersion([string]$TargetCsVersion) {
        if (-not $this.RawContent) {
            $this.RawContent = $this.GetRawContent()
        }

        if ($TargetCsVersion.StartsWith("v")) {
            $TargetCsVersion = $TargetCsVersion.Substring(1, $TargetCsVersion.Length - 1)
        }

        $tmpRawContent = $this.RawContent.ToLower()
        $this.ModifyAttribute($tmpRawContent, @("<Version>", "</Version>"), $TargetCsVersion)
        $this.ModifyAttribute($tmpRawContent, @("<ProductVersion>", "</ProductVersion>"), $TargetCsVersion)
        $this.ModifyAttribute($tmpRawContent, @("<AssemblyVersion>", "</AssemblyVersion>"), $TargetCsVersion)
        $this.ModifyAttribute($tmpRawContent, @("<FileVersion>", "</FileVersion>"), $TargetCsVersion)
        
        $this.RawContent | Out-File -FilePath $this.CsProjectFilePath
    }

    [void]ModifyAttribute([string]$tmpRawContent, [string[]]$AttributeNames, [string]$AttributeValue) {
        # First case scenario: <Version> </Version> exists
        if ($tmpRawContent.Contains($AttributeNames.ToLower()) -and $tmpRawContent.Contains($AttributeNames[1].ToLower())) {
            $allStrs = $this.RawContent.Split($AttributeNames, 3, "RemoveEmptyEntries")
            $allStrs[1] = "$($AttributeNames[0])$AttributeValue$($AttributeNames[1])"

            $this.RawContent = [string]::Join("", $allStrs)
            return
        }

        # the attribute doesn't exist, so we will have to add it to the file
        $allStrs = $this.RawContent.Split(@("<PropertyGroup>"), 3, "RemoveEmptyEntries")
        $commentAttr = "<!--This tag has been generated by ZipReleaser-->"
        $allStrs[0] += "<PropertyGroup>`n      $commentAttr`n      $($AttributeNames[0])$AttributeValue$($AttributeNames[1])`n"
        $this.RawContent = [string]::Join("", $allStrs)
    }

    [string]GetBinFolderPath() {
        return (Split-Path -Path $this.CsProjectFilePath) +
            [System.IO.Path]::DirectorySeparatorChar + "bin"
    }
}

function Split-StringValue {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true, ValueFromPipeline)]
        [string]$InputObject,
        [string[]]$Separators = " "
    )
    
    
    process {
        return $InputObject.Split($Separators, 
            [System.StringSplitOptions]::RemoveEmptyEntries) |
        ForEach-Object {
            if ([string]::IsNullOrWhiteSpace($_)) {
                return $null
            }

            return $_.Trim()
        } | Where-Object { $null -ne $_ }
    }
}

# This function tries to parse the contents inside of a .sln file (visual studio solution file)
# and returns an array of CsProjectContainer class instances.
function ConvertFrom-SlnFile {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [string]$SlnPath
    )
    
    process {
        [string]$allContent = Get-Content -Path $SlnPath -Raw
        [string]$parentPath = (Split-Path -Path $SlnPath) + [System.IO.Path]::DirectorySeparatorChar
    
        # parsed value will be something like this:
        # "{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "GUISharp", "GUISharp\GUISharp.csproj", "{6CB5C21A-EB16-48D6-B98A-F18D7CE46785}"
        $projectsStrs = $allContent | Split-StringValue -Separators @("Project(", "EndProject") | Where-Object {
            $_.StartsWith("`"{") -and $_.EndsWith("}`"")
        }
        
        [CsProjectContainer[]]$allCsProjectContainers = @()
        foreach ($currentProjectStr in $projectsStrs) {
            # csInfos will be something like this:
            # 0- {FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}")
            # 1- "GUISharp"
            # 2- "GUISharp\GUISharp.csproj"
            # 3- "{6CB5C21A-EB16-48D6-B98A-F18D7CE46785}"
            # do note that 0th index is useless for us here, because it's just a unique-id assigned to the current
            # solution (ig? because it's shared between all of the csproject in the solution, most of the times.).
            # index 1 is the project name;
            # index 2 is the project's RELATIVE path (we have to convert it to absolute path);
            # index 3 is the project unique-id;
            $csInfos = $currentProjectStr | Split-StringValue -Separators @("=", ",") | ForEach-Object {
                $_.Trim("`"")
            }
            $allCsProjectContainers += [CsProjectContainer]::new(
                $parentPath + $csInfos[2],              # path
                $csInfos[1],                            # project name
                $null,                                  # the raw conent (which will be set later)
                (Split-Path -Path ($SlnPath) -Leaf),    # the sln name
                $csInfos[3]                             # UUID
            )
        }
    
        return $allCsProjectContainers
    }
}

